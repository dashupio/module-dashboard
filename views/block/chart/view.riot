<block-chart-view>
  <div class="card h-100">
    <div if={ props.block.name } class="card-header d-flex">
      { props.block.name }
      <span class="ml-auto">
        { `${range === 'day' ? '' : `${ucfirst(range || 'month')} of `}${moment(props.date || new Date()).startOf(range || 'month').format('MMM Do')}` }
      </span>
    </div>
    <div if={ !state.loading } class="card-body d-flex flex-0 align-items-center" if={ state.total || state.total === 0 }>
      <div class="w-100">
        <div class={ `chart-title text-${props.block.color || 'primary'} text-bold h2 mb-0` } title={ `${range === 'day' ? '' : `${ucfirst(range || 'month')} of `}${moment(props.date || new Date()).startOf(range || 'month').format('MMM Do')}` } data-toggle="tooltip">
          <hbs template={ props.block.display || '{{value}}' } data={ { value : state.current } } />
          { ` this ${(range || 'month')}` }
        </div>
        <p class="m-0 text-bold">
          <span if={ state.last > state.current }>
            -<hbs template={ props.block.display || '{{value}}' } data={ { value : state.last - state.current } } />
            { ` (-${getDifference(state.last, state.current)}%) ` }
          </span>
          <span if={ state.last < state.current }>
            +<hbs template={ props.block.display || '{{value}}' } data={ { value : state.current - state.last } } />
            { ` (+${getDifference(state.last, state.current)}%) ` }
          </span>
          { state.last === state.current ? `No change` : '' }
          { ` since previous ${(range || 'month')}` }
          (<hbs template={ props.block.display || '{{value}}' } data={ { value : state.last } } />)
        </p>
      </div>
    </div>
    <div if={ !state.loading } class={ `card-body d-flex flex-column chart-${props.block.color || 'primary'}` }>
      <dashup-view if={ state.chart } dashup={ props.dashup } type="block" struct="chart" view="chart" class="d-flex flex-1" view-class="d-flex flex-1" chart={ state.chart } />
    </div>
  </div>

  <script>
    // import moment
    import moment from 'moment';
    import handlebars from 'handlebars';

    // export default
    export default class BlockChartView {
      
      /**
       * on before mount
       */
      onBeforeMount() {
        // bind methods
        this.init = this.init.bind(this);
        this.ucfirst = (str) => {
          // return
          return str.charAt(0).toUpperCase() + str.slice(1);
        };
        this.moment = moment;
        this.context = JSON.stringify(this.props.context);

        // bind
        this.date  = this.props.date || new Date();
        this.range = this.props.range || 'month';
      }

      /**
       * on mounted
       */
      onMounted() {
        // check frontend
        if (typeof window === 'undefined') return;

        // get chart then update
        this.init();

        // update
        this.props.page.on('do.data.blocks', this.init);
      }

      /**
       * on mounted
       */
      onBeforeUnmount() {
        // check frontend
        if (typeof window === 'undefined') return;

        // update
        this.props.page.removeListener('do.data.blocks', this.init);
      }

      /**
       * should update
       */
      shouldUpdate(newProps, prevProps) {
        // current
        const context = JSON.stringify(newProps.context);
        
        // check current
        if (context !== this.context) {
          // context
          this.context = JSON.stringify(newProps.context);

          // init again
          this.init();

          // get chart then update
          return true;
        }

        // check chart
        if (JSON.stringify(this.chart) !== JSON.stringify(this.state.chart)) {
          // set chart
          this.chart = this.state.chart;

          // return true
          return true;
        }

        // check loading
        if (this.state.loading !== this.loading) {
          // set loading
          this.loading = this.state.loading;

          // return true
          return true;
        }

        // check props
        if (prevProps.date !== newProps.date) return true;
        if (prevProps.range !== newProps.range) return true;
        if (JSON.stringify(newProps.block) !== JSON.stringify(prevProps.block)) return true;

        // return true
        return false;
      }

      /**
       * on mounted
       */
      onUpdated() {
        // check frontend
        if (typeof window === 'undefined') return;

        // check date
        if ((this.props.date && this.props.date !== this.date) || (this.props.range && this.props.range !== this.range)) {
          // set date
          this.date  = this.props.date;
          this.range = this.props.range || 'month';

          // get chart then update
          this.init();
        }
      }

      /**
       * init
       */
      async init() {
        // check loading
        if (this.state.loading) return;

        // loading
        this.update({
          loading : true,
        });

        // oppts
        const opts = await this.getChart();

        // loading
        this.chart = null;
        this.update({
          ...opts,

          loading : false,
        });
      }

      /**
       * get difference
       */
      getDifference(a, b) {
        // return difference
        return (100 * Math.abs((a - b) / ((a + b) / 2))).toFixed(2);
      }

      /**
       * gets all fields
       */
      getFields() {
        // reduce
        return Array.from(this.props.dashup.get('pages').values()).filter((page) => {
          // return page
          return page.get('type') === 'form' && page.get('data.model') === this.props.block.model;
        }).reduce((accum, page) => {
          // check page
          if (!page || !page.get('data.fields')) return accum;

          // loop fields
          accum.push(...page.get('data.fields'));

          // return accum
          return accum;
        }, []);
      }

      /**
       * fix context
       */
      fixContext(where) {
        // tempates
        if (!this.__templates) this.__templates = {};

        // iterate object
        const iter = (obj) => {
          // check keys
          Object.keys(obj).forEach((key) => {
            // iterate sub
            if (typeof obj[key] === 'object') return obj[key] = iter(obj[key]);

            // check string
            if (typeof obj[key] === 'string' && obj[key].includes('{{')) {
              // log context
              if (!this.__templates[obj[key]]) this.__templates[obj[key]] = handlebars.compile(obj[key]);

              // key
              obj[key] = this.__templates[obj[key]](this.props.context);
            }
          });

          // return fixed
          return obj;
        };

        // iterate object
        return iter(where);
      }

      /**
       * get chart
       */
      async getChart() {
        // return nothing
        if (!this.props.block.model) return;

        // create value
        const configs = {
          day : {
            sub    : 'hour',
            amount : 24,
          },
          week : {
            sub    : 'day',
            amount : 14,
          },
          month : {
            sub    : 'day',
            amount : 31,
          },
        };

        // get model
        const model = this.props.dashup.page(this.props.block.model);

        // filter
        const filter = typeof this.props.block.filter === 'string' ? JSON.parse(this.props.block.filter) : [];

        // get metric
        const metric = this.props.block.metric || 'avg';
        const grouping = this.props.block.grouping || 'total';

        // get field
        const field = this.props.block.field ? this.getFields().find((f) => f.uuid === this.props.block.field) : null;

        // key
        const fieldKey = field ? (field.type === 'date' ? `${(field.name || field.uuid)}.duration` : (field.name || field.uuid)) : null;

        // set type
        let data = null;

        // get query
        const getQuery = () => {
          // create query
          let query = model;

          // check filters
          filter.forEach((where) => {
            query = query.where(this.fixContext(where));
          });

          // return query
          return query;
        };

        // group key
        let groupKey = null;

        // set key
        if (grouping === 'total' || grouping === 'created') {
          // updated
          groupKey = 'created_at';
        } else if (grouping === 'updated') {
          // updated
          groupKey = 'updated_at';
        }

        // check grouping
        if (groupKey) {
          // create data
          const createData = async (fn) => {
            // get config
            const subConfig = configs[this.range];

            // create loop array
            const loopArr = [];

            // set amount
            if (this.range === 'month') {
              // set amount
              subConfig.amount = moment(this.date || new Date()).daysInMonth();
            }

            // for each
            for (let i = 0; i < subConfig.amount; i++) {
              // push
              loopArr.push(i);
            }

            // create data
            return {
              last : await fn(
                getQuery()
                .gt(groupKey, moment(this.date).subtract(1, `${this.range}s`).startOf(this.range).toDate())
                .lt(groupKey, moment(this.date).startOf(this.range).toDate())
              ),
              total : await fn(getQuery()),
              current : await fn(
                getQuery()
                .gt(groupKey, moment(this.date).startOf(this.range).toDate())
                .lt(groupKey, moment(this.date).add(1, `${this.range}s`).startOf(this.range).toDate())
              ),
              chart : await Promise.all(loopArr.map(async (i) => {
                return {
                  label  : moment(this.date).subtract(i, `${subConfig.sub}s`).startOf(subConfig.sub).toDate(),
                  amount : await fn(
                    await getQuery()
                    .gt(groupKey, moment(this.date).subtract(i, `${subConfig.sub}s`).startOf(subConfig.sub).toDate())
                    .lt(groupKey, moment(this.date).subtract((i - 1), `${subConfig.sub}s`).startOf(subConfig.sub).toDate())
                  )
                };
              })),
            };
          };

          // get one value...
          if (metric === 'count' || !metric) {
            // set data
            data = await createData((q) => {
              // return counted
              return q.count();
            });
          } else if (!field) {
            // return json
            return;
          } else if (metric === 'sum') {
            // set data
            data = await createData(async (q) => {
              // return counted
              return q.gt(fieldKey, 0).sum(fieldKey) || 0;
            });
          } else if (metric === 'avg') {
            // set data
            data = await createData(async (q) => {
              // return counted
              return await q.gt(fieldKey, 0).avg(fieldKey) || 0;
            });
          } else if (metric === 'min') {
            // set data
            data = await createData(async (q) => {
              // get value
              const value = await q.gt(fieldKey, 0).sort(fieldKey, 1).findOne();

              // return counted
              return value ? value.get(fieldKey) : 0;
            });
          } else if (metric === 'max') {
            // set data
            data = await createData(async (q) => {
              // get value
              const value = await q.gt(fieldKey, 0).sort(fieldKey, -1).findOne();

              // return counted
              return value ? value.get(fieldKey) : 0;
            });
          }
        }

        // fix nullified values
        if (data.last === null) data.last = 0;
        if (data.total === null) data.total = 0;
        if (data.current === null) data.current = 0;

        // check data
        if (!data) return {};
        
        // return parsed data
        return {
          ...data,

          chart : {
            series : [{
              name : model.get('name'),
              data : data.chart.map((item) => item.amount || 0),
            }],
            chart : {
              type      : 'area',
              sparkline : {
                enabled : true
              },
            },
            dataLabels : {
              enabled : false
            },
            stroke : {
              curve : 'smooth'
            },
            fill : {
              opacity : 0.3
            },
            xaxis : {
              type       : 'datetime',
              categories : data.chart.map((item) => `${item.label}`),
              crosshairs : {
                width : 1
              },
            },
            tooltip : {
              x : {
                format : 'dd/MM/yy HH:mm'
              },
            },
          }
        };
      }
    }
  </script>
</block-chart-view>